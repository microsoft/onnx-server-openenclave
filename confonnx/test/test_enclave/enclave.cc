// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#include <stdexcept>
#include <iostream>
#include <openenclave/enclave.h>

#include "server/shared/curl_helper.h"
#include "server/enclave/threading.h"
#include "server/enclave/key_vault_provider.h"
#include "server/enclave/key_vault_hsm_provider.h"
#include "test/helpers/crypto_helpers.h"

#ifdef HAVE_LIBSKR
#include <skr/skr.h>
#endif

#include "test_t.h"  // generated by oeedger8r

using namespace onnxruntime::server;
using namespace onnxruntime::server::test;

void _InitTest(bool verbose) {
  std::cout << "initializing..." << std::endl;
  oe_load_module_host_socket_interface();
  oe_load_module_host_resolver();
  initialize_oe_pthreads();
  CurlInit(verbose);
#ifdef HAVE_LIBSKR
  skr_initialize();
#endif
  std::cout << "initialization done" << std::endl;
}

void _CleanTest() {
  CurlCleanup();
#ifdef HAVE_LIBSKR
  skr_terminate();
#endif
}

// Note: All test functions are separated out with _ prefix to allow setting
//       breakpoints easily via gdb, otherwise it would pick up the host wrapper.

void _TestEnclaveCallCurl(const std::string& url, bool verbose) {
  _InitTest(verbose);

  std::string response = Curl(url, {}, {});
  if (response.empty()) {
    throw std::logic_error("Curl response empty");
  }

  _CleanTest();
}

extern "C" void TestEnclaveCallCurl(const char* url, bool verbose) {
  std::cout << "Starting: TestEnclaveCallCurl" << std::endl;
  if (!url) {
    std::cerr << "ERROR: null input" << std::endl;
    abort();
  }
  try {
    _TestEnclaveCallCurl(url, verbose);
  } catch (std::exception& exc) {
    std::cerr << "Exception thrown: " << exc.what() << std::endl;
    abort();
  } catch (...) {
    std::cerr << "unknown exception" << std::endl;
    abort();
  }
  std::cout << "Finished: TestEnclaveCallCurl" << std::endl;
}

void _TestEnclaveKeyVault(const std::string& app_id, const std::string& app_pwd,
                          const std::string& vault_url,
                          const std::string& fixed_key_name, const std::string& fixed_key_value,
                          bool verbose) {
  _InitTest(verbose);

  auto kvc = KeyVaultConfig(app_id, app_pwd, vault_url, fixed_key_name);
  auto kp = KeyVaultProvider::Create(std::move(kvc));
  CheckSecret(kp, fixed_key_value);

  _CleanTest();
}

extern "C" void TestEnclaveKeyVault(const char* app_id, const char* app_pwd,
                                    const char* vault_url,
                                    const char* fixed_key_name, const char* fixed_key_value,
                                    bool verbose) {
  std::cout << "Starting: TestEnclaveKeyVault" << std::endl;
  if (!app_id || !app_pwd || !vault_url || !fixed_key_name || !fixed_key_value) {
    std::cerr << "ERROR: null input" << std::endl;
    abort();
  }
  try {
    _TestEnclaveKeyVault(app_id, app_pwd, vault_url, fixed_key_name, fixed_key_value, verbose);
  } catch (std::exception& exc) {
    std::cerr << "Exception thrown: " << exc.what() << std::endl;
    abort();
  } catch (...) {
    std::cerr << "unknown exception" << std::endl;
    abort();
  }
  std::cout << "Finished: TestEnclaveKeyVault" << std::endl;
}

#ifdef HAVE_LIBSKR
void _TestEnclaveKeyVaultHsm(const std::string& app_id, const std::string& app_pwd,
                             const std::string& vault_url, const std::string& attestation_url,
                             const std::string& key_name,
                             bool verbose,
                             bool keep_key) {
  _InitTest(verbose);

  KeyVaultConfig kvc(app_id, app_pwd, vault_url, key_name, attestation_url);

  std::unique_ptr<confmsg::KeyProvider> kp;
  std::cout << "creating key provider" << std::endl;
  kp = KeyVaultHsmProvider::Create(std::move(kvc));

  std::vector<uint8_t> key = kp->GetCurrentKey();
  uint32_t key_version = kp->GetCurrentKeyVersion();
  std::cout << "Key: " << Bytes2Hex(key) << std::endl;
  std::cout << "Key version: " << key_version << std::endl;

  // Key rollover
  bool sync_only = false;
  kp->RefreshKey(sync_only);

  std::vector<uint8_t> new_key = kp->GetCurrentKey();
  uint32_t new_key_version = kp->GetCurrentKeyVersion();
  std::cout << "New key: " << Bytes2Hex(new_key) << std::endl;
  std::cout << "New key version: " << new_key_version << std::endl;

  if (!keep_key) {
    kp->DeleteKey();
  }

  if (new_key_version != key_version + 1) {
    throw std::logic_error("unexpected key version");
  }

  if (new_key == key) {
    throw std::logic_error("unexpected key value");
  }

  _CleanTest();
}

extern "C" void TestEnclaveKeyVaultHsm(const char* app_id, const char* app_pwd,
                                       const char* vault_url, const char* attestation_url,
                                       const char* key_name,
                                       bool verbose,
                                       bool keep_key) {
  std::cout << "Starting: TestEnclaveKeyVaultHsm" << std::endl;
  if (!app_id || !app_pwd || !vault_url || !attestation_url || !key_name) {
    std::cerr << "ERROR: null input" << std::endl;
    abort();
  }
  try {
    _TestEnclaveKeyVaultHsm(app_id, app_pwd, vault_url, attestation_url, key_name, verbose, keep_key);
  } catch (std::exception& exc) {
    std::cerr << "Exception thrown: " << exc.what() << std::endl;
    abort();
  } catch (...) {
    std::cerr << "unknown exception" << std::endl;
    abort();
  }
  std::cout << "Finished: TestEnclaveKeyVaultHsm" << std::endl;
}

void _TestEnclaveCreateKeyVaultHsmKey(const std::string& app_id, const std::string& app_pwd,
                                      const std::string& vault_url, const std::string& key_name,
                                      const std::string& attestation_url,
                                      bool verbose) {
  _InitTest(verbose);
  auto kvc = KeyVaultConfig(app_id, app_pwd, vault_url, key_name, attestation_url);
  KeyVaultHsmProvider::Create(std::move(kvc));
  _CleanTest();
}

extern "C" void TestEnclaveCreateKeyVaultHsmKey(const char* app_id, const char* app_pwd,
                                                const char* vault_url, const char* key_name,
                                                const char* attestation_url,
                                                bool verbose) {
  try {
    _TestEnclaveCreateKeyVaultHsmKey(app_id, app_pwd, vault_url, key_name, attestation_url, verbose);
  } catch (std::exception& exc) {
    std::cerr << "Exception thrown: " << exc.what() << std::endl;
    abort();
  } catch (...) {
    std::cerr << "unknown exception" << std::endl;
    abort();
  }
}

void _TestEnclaveExportKeyVaultHsmKey(const std::string& app_id, const std::string& app_pwd,
                                      const std::string& vault_url, const std::string& key_name,
                                      const std::string& attestation_url,
                                      bool verbose,
                                      uint8_t* output, size_t* output_size, size_t max_output_size,
                                      uint32_t* version) {
  _InitTest(verbose);
  auto kvc = KeyVaultConfig(app_id, app_pwd, vault_url, key_name, attestation_url);
  auto kp = KeyVaultHsmProvider::Create(std::move(kvc));
  auto key = kp->GetCurrentKey();
  if (key.size() > max_output_size) {
    throw std::logic_error("not enough space for key");
  }
  std::memcpy(output, key.data(), key.size());
  *output_size = key.size();
  *version = kp->GetCurrentKeyVersion();
  _CleanTest();
}

extern "C" void TestEnclaveExportKeyVaultHsmKey(const char* app_id, const char* app_pwd,
                                                const char* vault_url, const char* key_name,
                                                const char* attestation_url,
                                                bool verbose,
                                                uint8_t* output, size_t* output_size, size_t max_output_size,
                                                uint32_t* version) {
  try {
    _TestEnclaveExportKeyVaultHsmKey(app_id, app_pwd, vault_url, key_name, attestation_url, verbose, output, output_size, max_output_size, version);
  } catch (std::exception& exc) {
    std::cerr << "Exception thrown: " << exc.what() << std::endl;
    abort();
  } catch (...) {
    std::cerr << "unknown exception" << std::endl;
    abort();
  }
}

void _TestEnclaveDeleteKeyVaultHsmKey(const std::string& app_id, const std::string& app_pwd,
                                      const std::string& vault_url, const std::string& key_name,
                                      const std::string& attestation_url,
                                      bool verbose) {
  _InitTest(verbose);
  auto kvc = KeyVaultConfig(app_id, app_pwd, vault_url, key_name, attestation_url);
  auto kp = KeyVaultHsmProvider::Create(std::move(kvc));
  kp->DeleteKey();
  _CleanTest();
}

extern "C" void TestEnclaveDeleteKeyVaultHsmKey(const char* app_id, const char* app_pwd,
                                                const char* vault_url, const char* key_name,
                                                const char* attestation_url,
                                                bool verbose) {
  try {
    _TestEnclaveDeleteKeyVaultHsmKey(app_id, app_pwd, vault_url, key_name, attestation_url, verbose);
  } catch (std::exception& exc) {
    std::cerr << "Exception thrown: " << exc.what() << std::endl;
    abort();
  } catch (...) {
    std::cerr << "unknown exception" << std::endl;
    abort();
  }
}

#else
extern "C" void TestEnclaveKeyVaultHsm(const char*, const char*,
                                       const char*, const char*,
                                       const char*,
                                       bool,
                                       bool) { abort(); }

extern "C" void TestEnclaveCreateKeyVaultHsmKey(const char*, const char*,
                                                const char*, const char*,
                                                const char*,
                                                bool) { abort(); }

extern "C" void TestEnclaveExportKeyVaultHsmKey(const char*, const char*,
                                                const char*, const char*,
                                                const char*,
                                                bool,
                                                uint8_t*, size_t*, size_t,
                                                uint32_t*) { abort(); }

extern "C" void TestEnclaveDeleteKeyVaultHsmKey(const char*, const char*,
                                                const char*, const char*,
                                                const char*,
                                                bool) { abort(); }

#endif